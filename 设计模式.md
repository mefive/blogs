单例模式
function Singleton() {
    var instance;

    // 重写构造函数
     Singleton = function () {
        return instance;
    }

   // 保存之前的原型
    Singleton.prototype = this;
    Singleton.prototype.constructor = Singleton;

    instance = new Singleton();

    return instance;
}
以实现 new Singleton() === new Singleton()

工厂模式
写代码时不知道具体类型，需要运行时动态创建对象。这样的方法叫工厂方法

创建者模式
分离构建单个类的不同部分，分别编写类。组合成为一个类。分离关注点。

迭代器模式
暴露出方法用于遍历自身，用以把自身看成数组。 forEach() next()

装饰者模式
创建对象时，无法确定一些具体的功能（多是用于修饰展示给外的功能）。或者这些功能不适合写在类中。 
可以将其抽象出装饰类，暴露一些公共接口。被装饰类在某些时刻（或由外部调用）调用装饰类来装饰自己。

策略模式（还需要研究）
创建对象时，无法确定一些具体的内部算法。需要有外部策略对象提供。 
创建配置策略对象，原对象的某个时刻调用策略类的算法方法。

外观模式
聚合对象多个方法，整合为一个 API 暴露出去。

适配器模式
平滑进入另一套库所做的兼容，以达到不改之前代码的目的。从一种数据结构整理成另外一种数据结构。

中介者模式
对象之间通信的一种模式，彼此并不依赖。而依赖中介者，中介者负责转发消息（调用对象的方法）。

观察者模式
对象之间通信的一种模式，注册回调，合适的时机出发回调。比如 DOM 事件。 
发布订阅模式是通信双方对象都在中介对象上注册回调，由中介对象负责执行回调。比如事件总线。

桥接模式
使抽象和实现分离，以便二者独立变化。前端中抽象出逻辑，和具体对接那个 DOM 分离

其他心得
什么时候用继承，什么时候用组合，什么时候用 mixin

一个类当需要暴露另一个类的共性的属性的时候用继承 
只是内部使用另一个类，用组合 
一个类只能继承一个类，那么一些其他的需要与其他继承无关类共享的属性需要使用 mixin
