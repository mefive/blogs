#单例模式

    function Singleton() {

        var instance;

        

        // 重写构造函数

         Singleton = function () {

            return instance;

        }

       

       // 保存之前的原型

        Singleton.prototype = this;

        Singleton.prototype.constructor = Singleton;



        instance = new Singleton();

        

        return instance;

    }

以实现 `new Singleton() === new Singleton()`



#工厂模式

写代码时不知道具体类型，需要运行时动态创建对象。这样的方法叫工厂方法



#迭代器模式

暴露出方法用于遍历自身，用以把自身看成数组。 `forEach()` `next()`



#装饰者模式

创建对象时，无法确定一些具体的功能（多是用于修饰展示给外的功能）。或者这些功能不适合写在类中。

可以将其抽象出装饰类，暴露一些公共接口。被装饰类在某些时刻（或由外部调用）调用装饰类来装饰自己。



#策略模式（还需要研究）

创建对象时，无法确定一些具体的内部算法。需要有外部策略对象提供。

创建配置策略对象，原对象的某个时刻调用策略类的算法方法。



#外观模式

聚合对象多个方法，整合为一个 API 暴露出去。



#中介者模式

对象之间通信的一种模式，彼此并不依赖。而依赖中介者，中介者负责转发消息（调用对象的方法）。



#观察者模式

对象之间通信的一种模式，注册回调，合适的时机出发回调。比如 DOM 事件。

发布订阅模式是通信双方对象都在中介对象上注册回调，由中介对象负责执行回调。比如事件总线。
